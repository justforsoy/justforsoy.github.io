<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-12-17">

<title>Rock’s blog - 【Bayesian Modeling and Computation in Python】2.贝叶斯模型探索分析</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Rock’s blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/justforsoy" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">【Bayesian Modeling and Computation in Python】2.贝叶斯模型探索分析</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">读书摘录</div>
                <div class="quarto-category">贝叶斯建模</div>
                <div class="quarto-category">Bayesian Modeling and Computation in Python</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 17, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>上一章中贝叶斯推断是关于基于数据和先验知识，通过贝叶斯公式计算后验概率，从而得到后验分布的过程。但是现实中远没有这么简单，成功的贝叶斯分析还有很多其它挑战。<br>
本章将讨论其中的一些，包括检验模型假设、诊断推理结果和模型比较<a href="https://bayesiancomputationbook.com/markdown/chp_02.html">原文链接</a>。</p>
<section id="推断之前和之后都有要做的事情" class="level2">
<h2 class="anchored" data-anchor-id="推断之前和之后都有要做的事情">2.1. 推断之前和之后都有要做的事情！</h2>
<p>除推断外，一次成功的贝叶斯建模的工作列举：</p>
<ul>
<li>通过数值方法诊断推断结果质量；</li>
<li>模型批判，评价模型假设和模型预测结果；</li>
<li>模型比较，选择模型或者模型混合；</li>
<li>为特定受众准备结果。</li>
</ul>
<p>以上工作统称为<strong>贝叶斯模型探索分析（Exploratory Analysis of Bayesian Models）</strong>。</p>
</section>
<section id="理解你的假设" class="level2">
<h2 class="anchored" data-anchor-id="理解你的假设">2.2. 理解你的假设</h2>
<p>选择先验的一个问题是很难理解它们在模型计算中的效果。基于先验分布预测是一种理解假设的好方法。通过仅从先验预测分布抽样得到观察数据，我们完成从参数空间到观测空间的转换（参数分布 -&gt; 参数 -&gt; 先验预测分布 -&gt; 观测值）。 这被称为<strong>prior predictive checks</strong>。</p>
<p>举一个对足球建模的例子，我们感兴趣的是点球得分率。</p>
<p><img src="football_sketch.png" class="img-fluid"></p>
<p>模型假设期望射门角度<span class="math inline">\(\alpha\)</span>服从正态分布，进球概率模型为： <span class="math display">\[p\left(|\alpha| &lt; \tan^{-1}\left(\frac{L}{x}\right)\right) = 2\Phi\left(\frac{\tan^{-1}\left(\frac{L}{x}\right)}{\sigma}\right) - 1
\]</span></p>
<p>上述公式表达的是，足球射出角度<span class="math inline">\(\alpha\)</span>在±<span class="math inline">\(\tan^{-1}\left(\frac{L}{x}\right)\)</span>的概率（这样才能进球），其中<span class="math inline">\(L\)</span>是球门二分之一宽度，<span class="math inline">\(x\)</span>是球门中心到球员的距离。球员会尽量踢直线，但是有各种因素影响导致波动从而有标准差<span class="math inline">\(\sigma\)</span></p>
<p>上述公式中唯一未知的参数是<span class="math inline">\(\sigma\)</span>，我们可以选择它的先验来建模，例如服从Half-normal分布。则以上模型为：<br>
<span class="math display">\[\sigma \sim \mathcal{HN}(\sigma_{\sigma})\]</span></p>
<p><span class="math display">\[\text{p\_goal} = 2\Phi\left(\frac{\tan^{-1}\left(\frac{L}{x}\right)}{\sigma}\right) - 1\]</span></p>
<p><span class="math display">\[Y \sim \text{Bin}(n=1, p=\text{p\_goal})\]</span></p>
<p>我们很难直接抉择<span class="math inline">\(\sigma_{\sigma}\)</span>怎么选择，但是我们可以通过先验预测分布来理解它的影响。</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pytensor <span class="im">import</span> tensor <span class="im">as</span> tt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>az.style.use(<span class="st">"arviz-grayscale"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.dpi'</span>] <span class="op">=</span> <span class="dv">300</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">5201</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>half_length <span class="op">=</span> <span class="fl">3.66</span>  <span class="co"># meters</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>penalty_point <span class="op">=</span> <span class="dv">11</span>  <span class="co"># meters</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Phi(x):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculates the standard normal cumulative distribution function."""</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> tt.erf(x <span class="op">/</span> tt.sqrt(<span class="fl">2.0</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>ppss <span class="op">=</span> []</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>sigmas_deg <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">20</span>, <span class="dv">60</span>]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>sigmas_rad <span class="op">=</span> np.deg2rad(sigmas_deg)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sigma <span class="kw">in</span> sigmas_rad:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pm.Model() <span class="im">as</span> model:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        σ <span class="op">=</span> pm.HalfNormal(<span class="st">"σ"</span>, sigma)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        α <span class="op">=</span> pm.Normal(<span class="st">"α"</span>, <span class="dv">0</span>, σ)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        p_goal <span class="op">=</span> pm.Deterministic(<span class="st">"p_goal"</span>, <span class="dv">2</span> <span class="op">*</span> Phi(tt.arctan(half_length <span class="op">/</span> penalty_point) <span class="op">/</span> σ) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        pps <span class="op">=</span> pm.sample_prior_predictive(<span class="dv">250</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        ppss.append(pps)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [α, σ]
Sampling: [α, σ]
Sampling: [α, σ]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, subplot_kw<span class="op">=</span><span class="bu">dict</span>(projection<span class="op">=</span><span class="st">"polar"</span>), figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>max_angle <span class="op">=</span> np.arctan(half_length<span class="op">/</span>penalty_point)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sigma, pps, ax <span class="kw">in</span> <span class="bu">zip</span>(sigmas_deg, ppss, axes):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    cutoff <span class="op">=</span> pps.prior.data_vars.get(<span class="st">"p_goal"</span>)[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="fl">0.1</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    cax <span class="op">=</span> ax.scatter(pps.prior.data_vars.get(<span class="st">"α"</span>)[<span class="dv">0</span>][cutoff], np.ones_like(pps.prior.data_vars.get(<span class="st">"α"</span>)[<span class="dv">0</span>][cutoff]), c<span class="op">=</span>pps.prior.data_vars.get(<span class="st">"p_goal"</span>)[<span class="dv">0</span>][cutoff],</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>               marker<span class="op">=</span><span class="st">"."</span>, cmap<span class="op">=</span><span class="st">"viridis_r"</span>, vmin<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    ax.fill_between(np.linspace(<span class="op">-</span>max_angle, max_angle, <span class="dv">100</span>), <span class="dv">0</span>, <span class="fl">1.01</span>, alpha<span class="op">=</span><span class="fl">0.25</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks([])</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"$\sigma = \mathcal</span><span class="ch">{{</span><span class="ss">HN</span><span class="ch">}}</span><span class="ss">(</span><span class="sc">{</span>sigma<span class="sc">}</span><span class="ss">)$"</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    ax.plot(<span class="dv">0</span>,<span class="dv">0</span>, <span class="st">'o'</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>fig.colorbar(cax, extend<span class="op">=</span><span class="st">"min"</span>, ticks<span class="op">=</span>[<span class="dv">1</span>, <span class="fl">0.5</span>, <span class="fl">0.1</span>], shrink<span class="op">=</span><span class="fl">0.7</span>, aspect<span class="op">=</span><span class="dv">40</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>&lt;matplotlib.colorbar.Colorbar at 0x17b8dc090&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-5-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>对<span class="math inline">\(\sigma_\sigma\)</span> 分别取5,20,60的三个先验分布向后采样得到上述结果。<br>
灰色区域表示「射门期望能进球」范围（对应<span class="math inline">\(\alpha\)</span>，没有风、摩擦等干扰因素），颜色表示进球概率（对应p_goal，实际收干扰后的概率）。可以发现即使射的在灰色范围内，也不能100%进球。而对60来说，某些射向相反方向也有可能进球，这个分布可能不太好。</p>
<p>此时我们可以做更多选择：我们可以重新思考模型结构引入更多几何知识；或者我们可以使用先验来减少nonsensical的结果，或直接拟合看数据信息是否足够让后验结果合理。</p>
<p>下面的示例为一个逻辑回归模型，它包含一些二元变量，每个变量回归系数的先验为<span class="math inline">\(\mathcal{N}(0, 1)\)</span>。</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> expit</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>), sharex<span class="op">=</span><span class="va">True</span>,  sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> np.ravel(axes)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> dim, ax <span class="kw">in</span> <span class="bu">zip</span>([<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">20</span>], axes):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    β <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, size<span class="op">=</span>(<span class="dv">10000</span>, dim))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.random.binomial(n<span class="op">=</span><span class="dv">1</span>, p<span class="op">=</span><span class="fl">0.75</span>, size<span class="op">=</span>(dim, <span class="dv">500</span>))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    az.plot_kde(expit(β <span class="op">@</span> X).mean(<span class="dv">1</span>), ax<span class="op">=</span>ax)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"</span><span class="sc">{</span>dim<span class="sc">}</span><span class="ss"> predictors"</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    ax.set_xticks([<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>])</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>fig.text(<span class="fl">0.34</span>, <span class="op">-</span><span class="fl">0.075</span>, size<span class="op">=</span><span class="dv">18</span>, s<span class="op">=</span><span class="st">"mean of the simulated data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>Text(0.34, -0.075, 'mean of the simulated data')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-6-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>可以发现随着predictors的增加先验预测结果分布更偏向于产生极值。 因此我们可能需要一些更强的正则化先验（比如拉普拉斯分布）以保持模型远离极值。</p>
<p>上述的两个例子都表明先验不能孤立地理解，我们需要将它们放在特定模型的背景下。</p>
</section>
<section id="理解你的预测" class="level2">
<h2 class="anchored" data-anchor-id="理解你的预测">2.3. 理解你的预测</h2>
<p>我们可以通过<strong>posterior predictive checks</strong>来理解模型预测的效果。基本思想是后验预测分布抽样应该与观测数据类似。</p>
<p>下图是一个binomial model的例子。</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> stats.bernoulli(<span class="fl">0.7</span>).rvs(<span class="dv">100</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    θ <span class="op">=</span> pm.Beta(<span class="st">"θ"</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    y_obs <span class="op">=</span> pm.Binomial(<span class="st">"y_obs"</span>,n<span class="op">=</span><span class="dv">1</span>, p<span class="op">=</span>θ, observed<span class="op">=</span>Y)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    trace_b <span class="op">=</span> pm.sample(<span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [θ]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 18 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>pred_dist <span class="op">=</span> pm.sample_posterior_predictive(trace_b, model<span class="op">=</span>model).posterior_predictive.y_obs.values[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [y_obs]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="5" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      0.12% [5/4000 00:00&lt;00:09]
    </div>
    
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>), constrained_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>az.plot_dist(pred_dist.<span class="bu">sum</span>(<span class="dv">1</span>),</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>             hist_kwargs<span class="op">=</span>{<span class="st">"color"</span>:<span class="st">"C2"</span>}, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].axvline(Y.<span class="bu">sum</span>(), color<span class="op">=</span><span class="st">"C4"</span>, lw<span class="op">=</span><span class="fl">2.5</span>)<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].axvline(pred_dist.<span class="bu">sum</span>(<span class="dv">1</span>).mean(), color<span class="op">=</span><span class="st">"k"</span>, ls<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_yticks([])</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">"number of success"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>pps_ <span class="op">=</span> pred_dist.mean(<span class="dv">1</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot((np.zeros_like(pps_), np.ones_like(pps_)), (<span class="dv">1</span><span class="op">-</span>pps_, pps_), <span class="st">'C1'</span>, alpha<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot((<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span><span class="op">-</span>Y.mean(), Y.mean()), <span class="st">'C4'</span>, lw<span class="op">=</span><span class="fl">2.5</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot((<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span><span class="op">-</span>pps_.mean(), pps_.mean()), <span class="st">'k--'</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xticks((<span class="dv">0</span>,<span class="dv">1</span>))</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">"observed values"</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">"probability"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>Text(0, 0.5, 'probability')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-9-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>左图可以比较观测成功数据（蓝色）和后验预测的成功数值分布。右边是另一种概率方式的呈现。上图可知我们后验模型在平均值方面的预测很好。</p>
<p>后验预测还可以数值进行测试。一种计算方法是：<span class="math display">\[p_{B} = p(T_{sim} \leq T_{obs} \mid \tilde Y)\]</span></p>
<p>其中<span class="math inline">\(p_{B}\)</span>是Bayesian p-value：仿真生成的统计量<span class="math inline">\(T_{sim}\)</span>小于等于观测统计量<span class="math inline">\(T_{obs}\)</span>的概率。统计量<span class="math inline">\(T\)</span>可以是任意指标。在上面的例子中，<span class="math inline">\(T_{obs}\)</span>是成功率（均值）并且比较后验预测结果分布的成功率<span class="math inline">\(T_{sim}\)</span>。当 <span class="math inline">\(p_{B} = 0.5\)</span> 时 <span class="math inline">\(T_{sim}\)</span> 一半大于观测结果一半小于观测结果，这是拟合良好的预期结果。</p>
<p>以下是Bayesian p-value的绘制，注意 <code>az.plot_bpv(idata, kind="p_value")</code> 新版本绘制有误</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> az.from_dict(posterior_predictive<span class="op">=</span>{<span class="st">"y"</span>:pred_dist.reshape(<span class="dv">2</span>, <span class="dv">500</span>, <span class="dv">100</span>)}, observed_data<span class="op">=</span>{<span class="st">"y"</span>:Y})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>az.plot_bpv(idata, kind<span class="op">=</span><span class="st">"p_value"</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend([<span class="ss">f"bpv=</span><span class="sc">{</span>(Y.mean() <span class="op">&gt;</span> pred_dist.mean(<span class="dv">1</span>))<span class="sc">.</span>mean()<span class="sc">:.2f}</span><span class="ss">"</span>], handlelength<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>az.plot_bpv(idata, kind<span class="op">=</span><span class="st">"u_value"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_yticks([])</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xticks([<span class="fl">0.</span>, <span class="fl">0.5</span>, <span class="fl">1.</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/xarray/core/utils.py:494: FutureWarning: The return type of `Dataset.dims` will be changed to return a set of dimension names in future, in order to be more consistent with `DataArray.dims`. To access a mapping from dimension names to lengths, please use `Dataset.sizes`.
  warnings.warn(</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-11-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>以上是 Beta-Binomial model 的后验预测分布。左图显示有误待修复，右图中白色代表理想情况，黑线是预测值比例的KDE。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>az.plot_bpv(idata, kind<span class="op">=</span><span class="st">"t_stat"</span>, t_stat<span class="op">=</span><span class="st">"mean"</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"mean"</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>az.plot_bpv(idata, kind<span class="op">=</span><span class="st">"t_stat"</span>, t_stat<span class="op">=</span><span class="st">"std"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"standard deviation"</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xticks([<span class="fl">0.32</span>, <span class="fl">0.41</span>, <span class="fl">0.5</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-12-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>有很多 <span class="math inline">\(T\)</span> 统计量可以被选择。上图中左边为均值，右边为标准差。</p>
<p>下图有4个例子来帮助我们建立直觉。下图的蓝色线是同一份观测数据来自正态分布，并且有四个后验样本。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>n_obs <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>y_obs <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, size<span class="op">=</span>n_obs)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>idata1 <span class="op">=</span> az.from_dict(posterior_predictive<span class="op">=</span>{<span class="st">"y"</span>:np.random.normal(<span class="fl">0.5</span>, <span class="dv">1</span>, size<span class="op">=</span>(<span class="dv">1</span>, samples, n_obs))},</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                      observed_data<span class="op">=</span>{<span class="st">"y"</span>:y_obs})</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>idata2 <span class="op">=</span> az.from_dict(posterior_predictive<span class="op">=</span>{<span class="st">"y"</span>:np.random.normal(<span class="dv">0</span>, <span class="dv">2</span>, size<span class="op">=</span>(<span class="dv">1</span>, samples, n_obs))},</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>                      observed_data<span class="op">=</span>{<span class="st">"y"</span>:y_obs})</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>idata3 <span class="op">=</span> az.from_dict(posterior_predictive<span class="op">=</span>{<span class="st">"y"</span>:np.random.normal(<span class="dv">0</span>, <span class="fl">0.5</span>, size<span class="op">=</span>(<span class="dv">1</span>, samples,n_obs))},</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>                      observed_data<span class="op">=</span>{<span class="st">"y"</span>:y_obs})</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>idata4 <span class="op">=</span> az.from_dict(posterior_predictive<span class="op">=</span>{<span class="st">"y"</span>:np.concatenate(</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>                                                [np.random.normal(<span class="op">-</span><span class="fl">0.25</span>, <span class="dv">1</span>, size<span class="op">=</span>(<span class="dv">1</span>, samples<span class="op">//</span><span class="dv">2</span>, n_obs)),</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>                                                 np.random.normal(<span class="fl">0.25</span>, <span class="dv">1</span>, size<span class="op">=</span>(<span class="dv">1</span>, samples<span class="op">//</span><span class="dv">2</span>, n_obs))]</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>                                                                )},</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>                      observed_data<span class="op">=</span>{<span class="st">"y"</span>:y_obs})</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>idatas <span class="op">=</span> [idata1,</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>          idata2,</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>          idata3,</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>          idata4,</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="bu">len</span>(idatas), <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>), sharex<span class="op">=</span><span class="st">"col"</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idata, ax <span class="kw">in</span> <span class="bu">zip</span>(idatas, axes):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    az.plot_ppc(idata, ax<span class="op">=</span>ax[<span class="dv">0</span>], color<span class="op">=</span><span class="st">"C1"</span>, alpha<span class="op">=</span><span class="fl">0.01</span>, mean<span class="op">=</span><span class="va">False</span>, legend<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    az.plot_kde(idata.observed_data[<span class="st">"y"</span>].values, ax<span class="op">=</span>ax[<span class="dv">0</span>], plot_kwargs<span class="op">=</span>{<span class="st">"color"</span>:<span class="st">"C4"</span>, <span class="st">"zorder"</span>:<span class="dv">3</span>})</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].set_xlabel(<span class="st">""</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    az.plot_bpv(idata, kind<span class="op">=</span><span class="st">"p_value"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    az.plot_bpv(idata, kind<span class="op">=</span><span class="st">"u_value"</span>, ax<span class="op">=</span>ax[<span class="dv">2</span>])</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">2</span>].set_yticks([])</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">2</span>].set_xticks([<span class="fl">0.</span>, <span class="fl">0.5</span>, <span class="fl">1.</span>])</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ax_ <span class="kw">in</span> ax:</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        ax_.set_title(<span class="st">""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/arviz/plots/ppcplot.py:241: FutureWarning: color has been deprecated in favor of colors
  warnings.warn("color has been deprecated in favor of colors", FutureWarning)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-14-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>以上四个分布：</p>
<ol type="1">
<li>第一行的预测偏右<br>
</li>
<li>第二行的预测结果更离散</li>
<li>第三行的预测结果更集中</li>
<li>第四行的预测结果来自高斯混合分布</li>
</ol>
</section>
<section id="数值诊断" class="level2">
<h2 class="anchored" data-anchor-id="数值诊断">2.4. 数值诊断</h2>
<p>在本节中，我们将讨论马尔可夫链蒙特卡罗方法的最常见和最有用的诊断工具。</p>
<p>为了演示我们创建人造的后验：</p>
<p>第一个是<code>good_chains</code>来自 <span class="math inline">\(\Beta(2, 5)\)</span> ；<br>
第二个是 <code>bad_chains0</code> 代表不良的后验，通过对<code>good_chains</code>排序及增加小的高斯噪音产生：</p>
<ul>
<li>值之间不独立，相反它们是高度自相关的；</li>
<li>两组抽样不是一个分部，因为经历 reshape 和 重排序后，拆分为两部分。</li>
</ul>
<p>第三个是 <code>bad_chains1</code> 基于 <code>good_chains</code> 并随机在一些位置上插入一些来自同一分布的样本。这种场景很常见，代表一个采样器在一些参数空间表现很好，但是有一些区域很难采样到</p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>good_chains <span class="op">=</span> stats.beta.rvs(<span class="dv">2</span>, <span class="dv">5</span>,size<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">2000</span>))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>bad_chains0 <span class="op">=</span> np.random.normal(np.sort(good_chains, axis<span class="op">=</span><span class="va">None</span>), <span class="fl">0.05</span>,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>                               size<span class="op">=</span><span class="dv">4000</span>).reshape(<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>bad_chains1 <span class="op">=</span> good_chains.copy()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.random.randint(<span class="dv">1900</span>, size<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    bad_chains1[i<span class="op">%</span><span class="dv">2</span>:,i:i<span class="op">+</span><span class="dv">100</span>] <span class="op">=</span> np.random.beta(i, <span class="dv">950</span>, size<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>chains <span class="op">=</span> {<span class="st">"good_chains"</span>:good_chains,</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>          <span class="st">"bad_chains0"</span>:bad_chains0,</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>          <span class="st">"bad_chains1"</span>:bad_chains1}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="effective-sample-size" class="level3">
<h3 class="anchored" data-anchor-id="effective-sample-size">2.4.1. Effective Sample Size</h3>
<p>当使用 MCMC 方法时，我们需要足够的样本来估计后验分布。样本量是否充足不能直接由抽样次数觉得，因为 MCMC 有自相关性，所以其中包含的信息量会少于iid抽样结果。</p>
<p>Effective Sample Size (ESS) 可以被理解为考虑了自相关性后换算为iid抽样的样本量。</p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>az.ess(chains).data_vars</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="49">
<pre><code>Data variables:
    good_chains  float64 3.845e+03
    bad_chains0  float64 2.443
    bad_chains1  float64 597.0</code></pre>
</div>
</div>
<p>我们真实抽样次数为4000次，<code>good_chains</code> 与此结果很接近，<code>bad_chains1</code> 少了很多，<code>bad_chains0</code> 则更少。<br>
以上ess的算法为bulk即中心区域，可以切换为tail或quantile等。</p>
<p>可视化可以更好的理解ESS在参数空间上的变化。可以用 <code>az.plot_ess(., kind="quantiles")</code> 或者 <code>az.plot_ess(., kind="local")</code></p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, sharey<span class="op">=</span><span class="va">True</span>, sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>az.plot_ess(chains, kind<span class="op">=</span><span class="st">"local"</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>az.plot_ess(chains, kind<span class="op">=</span><span class="st">"quantile"</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/xarray/core/utils.py:494: FutureWarning: The return type of `Dataset.dims` will be changed to return a set of dimension names in future, in order to be more consistent with `DataArray.dims`. To access a mapping from dimension names to lengths, please use `Dataset.sizes`.
  warnings.warn(
/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/xarray/core/utils.py:494: FutureWarning: The return type of `Dataset.dims` will be changed to return a set of dimension names in future, in order to be more consistent with `DataArray.dims`. To access a mapping from dimension names to lengths, please use `Dataset.sizes`.
  warnings.warn(</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-17-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>一般认为 ESS 值要大于400，否则评估结果基本是不靠谱的。</p>
</section>
<section id="potential-scale-reduction-factor-hatr" class="level3">
<h3 class="anchored" data-anchor-id="potential-scale-reduction-factor-hatr">2.4.2. Potential Scale Reduction Factor <span class="math inline">\(\hat{R}\)</span></h3>
<p>在一般条件下有理论可证明，无论马尔科夫蒙特卡洛方法的起点为哪里都会得到相同的结果。然而这是在无限抽样的情况下，现实中我们只能有限抽样因此需要校验其收敛性。 一种校验方法是从不同起点执行多个 MCMC 链看几个链是否相似。<span class="math inline">\(\hat{R}\)</span> 就是这种诊断方法的结果。<br>
<span class="math inline">\(\hat{R}\)</span> 被解释为 MCMC 有限抽样造成的方差高估，因此成为 “potential scale reduction factor(PSRF)” 。 <span class="math inline">\(\hat{R} = 1\)</span> 意味着增加样本量不会再降低结果的方差。然而在实践中，最好将其视为一种诊断工具，而不要过度解释它。</p>
<blockquote class="blockquote">
<p><a href="http://staff.ustc.edu.cn/~zwp/teach/Stat-Comp/Lec9.pdf"><strong>计算方法</strong></a><br>
假设有 k 个链，每个链有 n 个样本，感兴趣的量为 <span class="math inline">\(\phi\)</span>，其在目标分布下有期望 <span class="math inline">\(\mu\)</span> 和 方差 <span class="math inline">\(\sigma ^ 2\)</span>。<br>
记 <span class="math inline">\(\phi_{jt}\)</span> 为链 j 的第 t 个样本 <span class="math inline">\(\phi\)</span> 的值，那么混合样本中，<span class="math inline">\(\mu\)</span> 的无偏估计为 <span class="math inline">\(\mu = \bar{\phi}\)</span> 。链之间的方差 B/n 和链内的方差 W 分别为： <span class="math display">\[B/n = \frac{1}{k-1} \sum_{j = 1}^{k}(\bar{\phi_j} - \bar{\phi})^2 \]</span> <span class="math display">\[W = \frac{1}{k(n-1)}\sum_{j = 1}^{k}\sum_{t=1}^{n}(\phi_{jt} - \bar{\phi}_j) ^ 2\]</span> 从而可以通过 B 和 W 加权估计 <span class="math inline">\(\sigma ^ 2\)</span>： <span class="math display">\[\hat{\sigma}_{+} ^ 2 = \frac{n - 1}{n}W + \frac{B}{n}\]</span> 如果初始值是从目标分布中抽取的，<span class="math inline">\(\hat{\sigma}_+^2\)</span>就是<span class="math inline">\(\sigma\)</span>的无偏估计。但是如过渡分散则会高估。考虑估计量<span class="math inline">\(\hat{\mu}\)</span>的抽样波动，方差的估计值为<span class="math inline">\(\hat{V} = \hat{\sigma}^2_+ + \frac{B}{kn}\)</span><br>
比较混合和链内的推断可以通过： <span class="math display">\[R = \frac{\hat{V}}{\sigma ^ 2}\]</span> 称 <span class="math inline">\(\sqrt{R}\)</span> 为 scale reduction factor(SRF) ，其估计值 potential scale reduction factor(PSRF) 为 <span class="math display">\[\hat{R} = \frac{\hat{V}}{W}\]</span></p>
</blockquote>
<p>理论上 <span class="math inline">\(\hat{R}\)</span> 应该为1，但是实际中会有一些误差。一般认为 <span class="math inline">\(\hat{R} &lt; 1.1\)</span> 时可以认为收敛。</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>az.rhat(chains).data_vars</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>Data variables:
    good_chains  float64 1.0
    bad_chains0  float64 2.392
    bad_chains1  float64 1.023</code></pre>
</div>
</div>
<p>以上结果说明 <code>good_chains</code> 收敛很好，<code>bad_chains0</code> 收敛很差，<code>bad_chains1</code> 稍微好一些但是仍然不符合标准。</p>
</section>
<section id="蒙特卡洛标准误" class="level3">
<h3 class="anchored" data-anchor-id="蒙特卡洛标准误">2.4.3. 蒙特卡洛标准误</h3>
<p>由于通过有限样本的 MCMC 来逼近后验，这引入了额外的不确定性。我们通过 Monte Carlo standard error (MCSE) 来评估引入的不确定性大小。<br>
如果我们评估参数的值精确度要到小数点后两位，则需要 MCSE 低于小数点后两位。<br>
当然 MCSE 仅在 ESS 足够高且 <span class="math inline">\(\hat{R}\)</span> 足够小时才有意义。</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>az.mcse(chains).data_vars</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<pre><code>Data variables:
    good_chains  float64 0.002561
    bad_chains0  float64 0.107
    bad_chains1  float64 0.00688</code></pre>
</div>
</div>
<p>与 ESS 一样，MCSE 在参数空间中变化，可能需要在不同区间（比如分位点）评估。我们可以进行可视化：</p>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>az.plot_mcse(chains)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-20-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>ESS ，<span class="math inline">\(\hat{R}\)</span> 和 MCSE 可以通过 <code>az.summary(.)</code> 一起计算：</p>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>az.summary(chains, kind<span class="op">=</span><span class="st">"diagnostics"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="59">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">mcse_mean</th>
<th data-quarto-table-cell-role="th">mcse_sd</th>
<th data-quarto-table-cell-role="th">ess_bulk</th>
<th data-quarto-table-cell-role="th">ess_tail</th>
<th data-quarto-table-cell-role="th">r_hat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">good_chains</td>
<td>0.003</td>
<td>0.002</td>
<td>3845.0</td>
<td>3883.0</td>
<td>1.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">bad_chains0</td>
<td>0.107</td>
<td>0.087</td>
<td>2.0</td>
<td>11.0</td>
<td>2.39</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">bad_chains1</td>
<td>0.007</td>
<td>0.005</td>
<td>597.0</td>
<td>1268.0</td>
<td>1.02</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="trace-plots" class="level3">
<h3 class="anchored" data-anchor-id="trace-plots">2.4.4. Trace Plots</h3>
<p>Trace Plots 可能是最常用的分析方法。从中我们可以观察到不同 chains 是否收敛到相似分布。</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>az.plot_trace(chains)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-22-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="autocorrelation-plots" class="level3">
<h3 class="anchored" data-anchor-id="autocorrelation-plots">2.4.5. Autocorrelation Plots</h3>
<p>自相关性是导致 MCMC 结果信息量不足的主要原因。我们可以通过自相关图来观察自相关性。</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>az.plot_autocorr(chains, combined<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-23-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="rank-plots" class="level3">
<h3 class="anchored" data-anchor-id="rank-plots">2.4.6. Rank Plots</h3>
<p>Rank Plots是另一种常见诊断方法。它先将所有链混合排序，在分别绘制各个链的rank分布。如果所有链都是从同一分布中抽取的，那么rank分布应该是相似的，并且为均匀分布。</p>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>az.plot_rank(chains, kind<span class="op">=</span><span class="st">"bars"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-24-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>az.plot_rank(chains, kind<span class="op">=</span><span class="st">"vlines"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-25-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Rank Plots 可能比 Trace Plots 更敏感。可以将它们一起绘制</p>
<div class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>az.plot_trace(chains, kind<span class="op">=</span><span class="st">"rank_bars"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-26-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>az.plot_trace(chains, kind<span class="op">=</span><span class="st">"rank_vlines"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-27-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="divergences散度" class="level3">
<h3 class="anchored" data-anchor-id="divergences散度">2.4.7. Divergences（散度）</h3>
<p>以上都是基于 MCMC 生成的样本进行诊断。另一种诊断方法是监控抽样过程。<br>
其中一个典型的例子是 Hamiltonian Monte Carlo (HMC) 中的Divergences，它是一种强大且敏感的方法，可以作为前面方法的补充。</p>
<p>以下是一个示例</p>
<ul>
<li>model_0：<span class="math inline">\(\theta_2\)</span> 服从 <span class="math inline">\([-\theta_1, \theta_1]\)</span>的均匀分布，而 <span class="math inline">\(\theta_1\)</span> 来自一个正态分布</li>
<li>model_1：<span class="math inline">\(\theta_2\)</span> 服从 <span class="math inline">\([-\theta_1, \theta_1]\)</span>的均匀分布，而 <span class="math inline">\(\theta_1\)</span> 来自一个半正态分布</li>
<li>model_2：<span class="math inline">\(\theta_2\)</span> 服从 <span class="math inline">\([-\theta_1, \theta_1]\)</span>的均匀分布，而 <span class="math inline">\(\theta_1\)</span> 来自一个正态分布</li>
</ul>
<div class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_0:</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    theta_1 <span class="op">=</span> pm.Normal(<span class="st">"theta_1"</span>, <span class="dv">0</span>, <span class="dv">1</span>, initval<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    theta_2 <span class="op">=</span> pm.Uniform(<span class="st">"theta_2"</span>, <span class="op">-</span>theta_1, theta_1)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    idata_0 <span class="op">=</span> pm.sample(return_inferencedata<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_1:</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    theta_1 <span class="op">=</span> pm.HalfNormal(<span class="st">"theta_1"</span>,<span class="dv">1</span> <span class="op">/</span> (<span class="dv">2</span><span class="op">/</span>np.pi)<span class="op">**</span><span class="fl">0.5</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    theta_2 <span class="op">=</span> pm.Uniform(<span class="st">"theta_2"</span>, <span class="op">-</span>theta_1, theta_1)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    idata_1 <span class="op">=</span> pm.sample(return_inferencedata<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_1bis:</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    theta_1 <span class="op">=</span> pm.HalfNormal(<span class="st">"theta_1"</span>,<span class="dv">1</span> <span class="op">/</span> (<span class="dv">2</span><span class="op">/</span>np.pi)<span class="op">**</span><span class="fl">0.5</span>)</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    theta_2 <span class="op">=</span> pm.Uniform(<span class="st">"theta_2"</span>, <span class="op">-</span>theta_1, theta_1)</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    idata_1bis <span class="op">=</span> pm.sample(return_inferencedata<span class="op">=</span><span class="va">True</span>, target_accept<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>idatas <span class="op">=</span> [idata_0, idata_1, idata_1bis]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [theta_1, theta_2]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 20 seconds.
There were 2202 divergences after tuning. Increase `target_accept` or reparameterize.
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [theta_1, theta_2]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 19 seconds.
There were 20 divergences after tuning. Increase `target_accept` or reparameterize.
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [theta_1, theta_2]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 19 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:02&lt;00:00 Sampling 4 chains, 2,202 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 20 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:02&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
</div>
<div class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">6</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> axes.reshape(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idata, ax, color <span class="kw">in</span> <span class="bu">zip</span>(idatas, axes, [<span class="st">"0.95"</span>, <span class="st">"1"</span>, <span class="st">"0.95"</span>]):</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    az.plot_trace(idata, kind<span class="op">=</span><span class="st">"rank_vlines"</span>, axes<span class="op">=</span>ax)<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    [ax_.set_facecolor(color) <span class="cf">for</span> ax_ <span class="kw">in</span> ax.ravel()]</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>fig.text(<span class="fl">0.45</span>, <span class="dv">1</span>, s<span class="op">=</span><span class="st">"model 0"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>fig.text(<span class="fl">0.45</span>, <span class="fl">0.67</span>, s<span class="op">=</span><span class="st">"model 1"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>fig.text(<span class="fl">0.45</span>, <span class="fl">0.33</span>, s<span class="op">=</span><span class="st">"model 1bis"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="84">
<pre><code>Text(0.45, 0.33, 'model 1bis')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-29-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>以上在KDEs图中可以看到底部的黑线，每个黑线代表一次divergence，说明抽样中产生了问题。</p>
<ul>
<li>model_0：有很多divergence，这是因为我们先验选择了正态分布，会出现 <span class="math inline">\(-\theta_1 &gt; \theta_1\)</span> 的情况；</li>
<li>model_1：divergence少了很多，因为我们先验选择了半正态分布，不会出现 <span class="math inline">\(-\theta_1 &gt; \theta_1\)</span> 的情况；</li>
<li>model_2：基于model_1，将 <code>target_accept</code> 从默认的0.8改为0.95，消除了所有divergence。</li>
</ul>
<p>我们也可以用散点图来观察divergence：</p>
<div class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idata, ax, model <span class="kw">in</span> <span class="bu">zip</span>(idatas, axes, [<span class="st">"model 0"</span>, <span class="st">"model 1"</span>, <span class="st">"model 1bis"</span>]):</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    az.plot_pair(idata, divergences<span class="op">=</span><span class="va">True</span>, scatter_kwargs<span class="op">=</span>{<span class="st">"color"</span>:<span class="st">"C1"</span>}, divergences_kwargs<span class="op">=</span>{<span class="st">"color"</span>:<span class="st">"C4"</span>}, ax<span class="op">=</span>ax)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">""</span>)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">""</span>)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    ax.set_title(model)</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">'θ2'</span>, rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">'θ1'</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/xarray/core/utils.py:494: FutureWarning: The return type of `Dataset.dims` will be changed to return a set of dimension names in future, in order to be more consistent with `DataArray.dims`. To access a mapping from dimension names to lengths, please use `Dataset.sizes`.
  warnings.warn(</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="85">
<pre><code>Text(0.5, 0, 'θ1')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-30-output-3.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="采样器参数和其他诊断信息" class="level3">
<h3 class="anchored" data-anchor-id="采样器参数和其他诊断信息">2.4.8. 采样器参数和其他诊断信息</h3>
<p>大部分抽样方法都有影响效果的超参数，比如有时增大 <code>target_accept</code> 可以消除 divergence。还有其他参数可以调整，比如有些模型更复杂需要更多的跌打，可以增加 tune 去增大 ESS 和减少 <span class="math inline">\(\hat{R}\)</span>。也可以增加采样次数，但是一般效果不大。重新参数化、改进模型结构、提供更多信息的先验，甚至更改模型通常会更有效。</p>
</section>
</section>
<section id="模型比较" class="level2">
<h2 class="anchored" data-anchor-id="模型比较">2.5. 模型比较</h2>
<p>建模时不能过于简单从而丢失信息，也不能过于复杂从而过拟合。</p>
<p>一种有用的解决方案是计算泛化误差，也称为样本外预测准确性。这是指模型在新数据上的表现。 <span class="math display">\[\text{ELPD} = \sum_{i=1}^{n} \int p_t(\tilde y_i) \; \log p(\tilde y_i \mid y_i) \; d\tilde y_i\]</span></p>
<p>上述公式被称为 expected log pointwise predictive density (ELPD)。其中 <span class="math inline">\(p_t(\tilde y_i)\)</span> 是真实分布，<span class="math inline">\(p(\tilde y_i \mid y_i)\)</span> 是模型预测的后验分布。</p>
<p>现实生活中无法知道 <span class="math inline">\(p_t(\tilde y_i)\)</span> ，因此 ELPD 无法直接计算，可以通过下面公式代替： <span class="math display">\[\sum_{i=1}^{n} \log \int \ p(y_i \mid \boldsymbol{\theta}) \; p(\boldsymbol{\theta} \mid y) d\boldsymbol{\theta}\]</span></p>
<section id="cross-validation-and-loo" class="level3">
<h3 class="anchored" data-anchor-id="cross-validation-and-loo">2.5.1. Cross-validation and LOO</h3>
<p>Leave-one-out cross-validation (LOO-CV) 是交叉验证的一种特别方法，每次只留一个数据点作为测试集，其余作为训练集。 <span class="math display">\[\text{ELPD}_\text{LOO-CV} = \sum_{i=1}^{n} \log
    \int \ p(y_i \mid \boldsymbol{\theta}) \; p(\boldsymbol{\theta} \mid y_{-i}) d\boldsymbol{\theta}
\]</span></p>
<p>以上直接计算消耗很大，好在可以用 Pareto smoothed importance sampling leave-one-out cross validation (PSIS-LOO-CV) 近似，后面会称为 LOO 。以下是示例：</p>
<div class="cell" data-execution_count="161">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>y_obs <span class="op">=</span>  np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, size<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>idatas_cmp <span class="op">=</span> {}</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> mA:</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">"σ"</span>, <span class="dv">1</span>)</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pm.SkewNormal(<span class="st">"y"</span>, <span class="dv">0</span>, σ, observed<span class="op">=</span>y_obs)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    loglik <span class="op">=</span> pm.Deterministic(<span class="st">'log_likelihood'</span>, pm.logp(y, y_obs))</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    idataA <span class="op">=</span> pm.sample(return_inferencedata<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    idataA.add_groups({<span class="st">"posterior_predictive"</span>: {<span class="st">"y"</span>:pm.sample_posterior_predictive(idataA).posterior_predictive.y.values}})</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    idataA.add_groups({<span class="st">"log_likelihood"</span>: {<span class="st">"y"</span>:idataA.posterior.log_likelihood}})</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    idatas_cmp[<span class="st">"mA"</span>] <span class="op">=</span> idataA</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> mB:</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">"σ"</span>, <span class="dv">1</span>)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pm.Normal(<span class="st">"y"</span>, <span class="dv">0</span>, σ, observed<span class="op">=</span>y_obs)</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    loglik <span class="op">=</span> pm.Deterministic(<span class="st">'log_likelihood'</span>, pm.logp(y, y_obs))</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>    idataB <span class="op">=</span> pm.sample(return_inferencedata<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    idataB.add_groups({<span class="st">"posterior_predictive"</span>: {<span class="st">"y"</span>:pm.sample_posterior_predictive(idataB).posterior_predictive.y.values}})</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>    idataB.add_groups({<span class="st">"log_likelihood"</span>: {<span class="st">"y"</span>:idataB.posterior.log_likelihood}})</span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>    idatas_cmp[<span class="st">"mB"</span>] <span class="op">=</span> idataB</span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> mC:</span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> pm.Normal(<span class="st">"μ"</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">"σ"</span>, <span class="dv">1</span>)</span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> pm.Normal(<span class="st">"y"</span>, μ, σ, observed<span class="op">=</span>y_obs)</span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>    loglik <span class="op">=</span> pm.Deterministic(<span class="st">'log_likelihood'</span>, pm.logp(y, y_obs))</span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>    idataC <span class="op">=</span> pm.sample(return_inferencedata<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>    idataC.add_groups({<span class="st">"posterior_predictive"</span>: {<span class="st">"y"</span>:pm.sample_posterior_predictive(idataC).posterior_predictive.y.values}})</span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a>    idataC.add_groups({<span class="st">"log_likelihood"</span>: {<span class="st">"y"</span>:idataC.posterior.log_likelihood}})</span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a>    idatas_cmp[<span class="st">"mC"</span>] <span class="op">=</span> idataC</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [σ]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 20 seconds.
There were 29 divergences after tuning. Increase `target_accept` or reparameterize.
Sampling: [y]
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [σ]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 19 seconds.
Sampling: [y]
Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [μ, σ]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 21 seconds.
Sampling: [y]</code></pre>
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 29 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="4000" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [4000/4000 00:00&lt;00:00]
    </div>
    
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="4000" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [4000/4000 00:00&lt;00:00]
    </div>
    
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="8000" class="" max="8000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [8000/8000 00:01&lt;00:00 Sampling 4 chains, 0 divergences]
    </div>
    
</div>
<div class="cell-output cell-output-display">

<style>
    /* Turns off some styling */
    progress {
        /* gets rid of default border in Firefox and Opera. */
        border: none;
        /* Needs to be in here for Safari polyfill so background images work as expected. */
        background-size: auto;
    }
    progress:not([value]), progress:not([value])::-webkit-progress-bar {
        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);
    }
    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {
        background: #F44336;
    }
</style>
</div>
<div class="cell-output cell-output-display">

    <div>
      <progress value="4000" class="" max="4000" style="width:300px; height:20px; vertical-align: middle;"></progress>
      100.00% [4000/4000 00:00&lt;00:00]
    </div>
    
</div>
</div>
<div class="cell" data-execution_count="162">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="op">=</span> az.compare(idatas_cmp)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span>.<span class="bu">round</span>(<span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/arviz/stats/stats.py:803: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.7 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.
  warnings.warn(
/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/arviz/stats/stats.py:307: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise in a future error of pandas. Value 'True' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.
  df_comp.loc[val] = (
/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/arviz/stats/stats.py:307: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise in a future error of pandas. Value 'log' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.
  df_comp.loc[val] = (</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="162">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">rank</th>
<th data-quarto-table-cell-role="th">elpd_loo</th>
<th data-quarto-table-cell-role="th">p_loo</th>
<th data-quarto-table-cell-role="th">elpd_diff</th>
<th data-quarto-table-cell-role="th">weight</th>
<th data-quarto-table-cell-role="th">se</th>
<th data-quarto-table-cell-role="th">dse</th>
<th data-quarto-table-cell-role="th">warning</th>
<th data-quarto-table-cell-role="th">scale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">mA</td>
<td>0</td>
<td>-140.80</td>
<td>0.31</td>
<td>0.00</td>
<td>0.84</td>
<td>6.50</td>
<td>0.00</td>
<td>True</td>
<td>log</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mB</td>
<td>1</td>
<td>-141.02</td>
<td>0.89</td>
<td>0.21</td>
<td>0.16</td>
<td>6.82</td>
<td>0.80</td>
<td>False</td>
<td>log</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">mC</td>
<td>2</td>
<td>-142.10</td>
<td>1.95</td>
<td>1.30</td>
<td>0.00</td>
<td>6.84</td>
<td>0.97</td>
<td>False</td>
<td>log</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>注意：<code>PyMC更换新版本后计算结果与原文不一致，而且mA出现warning</code>。以上模型中mB最好，但是给出的列表中mA最好（本应最差），这是因为mA的计算有问题。</p>
<p>以上列含义：</p>
<ul>
<li>rank：对比排名；</li>
<li>elpd_loo：ELPD值；</li>
<li>p_loo：惩罚项的值。我们可以粗略地认为这个值是估计的有效参数数量（但不要太认真）。该值可能低于具有更多结构（如分层模型）的模型中参数的实际数量，或者当模型具有非常弱的预测能力并且可能指示严重的模型错误指定时，该值可能远高于实际数量；</li>
<li>elpd_diff：与最佳模型的ELPD差值；</li>
<li>weight：分配给每个模型的权重。这些权重可以粗略地解释为给定数据的每个模型（在比较模型中）的概率；</li>
<li>se：ELPD的标准误；</li>
<li>dse：ELPD差值的标准误；</li>
<li>warning：如果为 <code>True</code> 则这是一个警告，表明 LOO 近似可能不可靠；</li>
<li>scale：报告值的计算方式，默认为对数刻度。</li>
</ul>
</section>
<section id="expected-log-predictive-density" class="level3">
<h3 class="anchored" data-anchor-id="expected-log-predictive-density">2.5.2. Expected Log Predictive Density</h3>
<p>上述是全局比较，因此将模型和数据简化为单个数字。但LOO是逐点的总和，因此也可以通过<code>az.plot_elpd(.)</code>进行局部比较。</p>
</section>
<section id="pareto-shape-parameter" class="level3">
<h3 class="anchored" data-anchor-id="pareto-shape-parameter">2.5.3. Pareto Shape Parameter</h3>
<p>以上通过 <span class="math inline">\(\text{ELPD}_\text{LOO-CV}\)</span> 来逼近 LOO 。以上计算中 $$ 会有问题， 特别是 <span class="math inline">\(\hat \kappa &gt; 0.7\)</span>时（mA）。<br>
这种情况下的建议为：</p>
<ul>
<li>使用匹配矩法。通过一些额外的计算，可以转换从后验分布得出的 MCMC，以获得更可靠的重要性采样估计；</li>
<li>对有问题的观察结果执行精确的留一交叉验证或使用 k 折交叉验证；</li>
<li>使用对异常观察更稳健的模型。</li>
</ul>
<p>当以上问题发生时会在得到warning，可以可视化检查 $$</p>
<div class="cell" data-execution_count="173">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, (model, ax) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>((<span class="st">"mA"</span>, <span class="st">"mB"</span>, <span class="st">"mC"</span>), axes)):</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    loo_ <span class="op">=</span> az.loo(idatas_cmp[model], pointwise<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    az.plot_khat(loo_, ax<span class="op">=</span>ax, threshold<span class="op">=</span><span class="fl">0.09</span>, show_hlines<span class="op">=</span><span class="va">True</span>, hlines_kwargs<span class="op">=</span>{<span class="st">"hlines"</span>:<span class="fl">0.09</span>, <span class="st">"ls"</span>:<span class="st">"--"</span>})</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    ax.set_title(model)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> idx:</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>        axes[idx].set_ylabel(<span class="st">""</span>)</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> idx <span class="op">%</span> <span class="dv">2</span>:</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>        axes[idx].set_xlabel(<span class="st">""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/admin/blog/rock_blog/env/lib/python3.11/site-packages/arviz/stats/stats.py:803: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.7 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.
  warnings.warn(</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-33-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="hat-kappa-很大时-p_loo-的含义" class="level3">
<h3 class="anchored" data-anchor-id="hat-kappa-很大时-p_loo-的含义">2.5.4. <span class="math inline">\(\hat {\kappa}\)</span> 很大时 p_loo 的含义</h3>
<p>p_loo 可以宽松地解释为模型中参数的估计有效数量。当 <span class="math inline">\(\hat {\kappa}\)</span> 很大时，它还可以提供额外信息。具体可参考原文。</p>
</section>
<section id="loo-pit" class="level3">
<h3 class="anchored" data-anchor-id="loo-pit">2.5.5. LOO-PIT</h3>
<p>LOO除了声明一个模型比另一个模型更好之外，还可以用于其他目的。我们可以通过比较模型来更好地理解它们。随着模型复杂性的增加，仅仅通过查看其数学定义或我们用来实现它的代码来理解它就变得更加困难。因此，使用 LOO 或其他工具（如后验预测检查）比较模型可以帮助我们更好地理解它们。</p>
<p>对 posterior predictive checks（后验预测检查）的一个批评是我们使用数据两次，一次是为了拟合模型，一次是为了批评它。 LOO-PIT 为这个问题提供了答案。</p>
<div class="cell" data-execution_count="175">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> model, ax <span class="kw">in</span> <span class="bu">zip</span>((<span class="st">"mA"</span>, <span class="st">"mB"</span>, <span class="st">"mC"</span>), axes):</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    az.plot_loo_pit(idatas_cmp[model], y<span class="op">=</span><span class="st">"y"</span>, legend<span class="op">=</span><span class="va">False</span>, use_hdi<span class="op">=</span><span class="va">True</span>, ax<span class="op">=</span>ax)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    ax.set_title(model)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    ax.set_xticks([<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>])</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-34-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="model-averaging" class="level3">
<h3 class="anchored" data-anchor-id="model-averaging">2.5.6. Model Averaging</h3>
<p>像我们关于参数不确定性的贝叶斯学派一样。如果我们不能绝对确定模型就是模型（通常我们不能），那么我们应该在分析时考虑到这种不确定性。考虑模型不确定性的一种方法是对所有考虑的模型进行加权平均，为似乎能更好地解释或预测数据的模型赋予更多权重。</p>
<p>贝叶斯模型加权的一种方法是通过其 marginal likelihoods ，这称为 Bayesian Model Averaging 贝叶斯模型平均。虽然这在理论上很有吸引力，但在实践中却存在问题。另一种方法是使用 LOO 的值来估计每个模型的权重： <span class="math display">\[w_i = \frac {e^{-\Delta_i }} {\sum_j^k e^{-\Delta_j }}\]</span></p>
<p>其中 $_i $ 是当前与最优模型的 LOO 之差。这种方法称为 pseudo Bayesian model averaging 伪贝叶斯模型平均。</p>
<p>模型平均的另一个选择是叠加预测分布。主要思想是将多个模型组合在一个元模型中，从而最小化元模型和真实生成模型之间的差异。当使用对数评分规则时，这相当于计算： <span class="math display">\[\max_{w} \frac{1}{n} \sum_{i=1}^{n}log\sum_{j=1}^{k} w_j p(y_i \mid y_{-i}, M_j)\]</span></p>
<p>其中 n 是样本个数，k 是模型个数。为了有解约束 <span class="math inline">\(w_j \geq 0\)</span> 而且 <span class="math inline">\(\sum_{j=1}^{k} w_j = 1\)</span> 。 <span class="math inline">\(p(y_i \mid y_{-i}, M_j)\)</span> 是第 j 个模型的 leave-one-out 预测分布。</p>
</section>
</section>
<section id="练习" class="level2">
<h2 class="anchored" data-anchor-id="练习">2.6. 练习</h2>
<p>待完善</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>